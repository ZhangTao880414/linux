*** MySQL锁机制

    每个客户端连接都会在服务器进程中启动一个线程，这个连接的查询只会在这个线程中执行，该线程只能轮流在CPU核心或者CPU中运行;

    服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程;

    MYSQL5.5以后的版本提供了一个API，支持线程池插件，可以使用池中少量的线程来服务大量的连接;

**** 锁
     - 读锁(共享锁)
     - 写锁(排它锁)

       表锁是Mysql中最基本的锁策略，是开销最小的策略;

       行锁可以做大程度上的提高并发处理能力，同时也带来了最大的开销。行锁只在特定的存储引擎中实现，在Mysql服务器层没有实现行锁，他完全不了解存储引擎中锁的实现机制;

     - ACID

       - 原子性(atomicity):事务不可分割，要么全部执行，要么全部不执行

       - 一致性(consistency):数据库总是从一种状态到另一种状态.

       - 隔离性(isolation):通常来说，一个事务所做的修改在最终提交之前，对其他事务是不可见的.

       - 持久性(durability):一旦事务提交，则其所做的修改会永久保存在数据库中.此时即使系统崩溃，修改的内容也不会丢失.

       注意：隔离性只是“通常来说”事务之间是不可见的，因为事务是有隔离级别的
     - 死锁

       两个或者多个事务在同一资源上相互作用，并请求锁定对方占用的资源，从而导致恶性循环的现象;
     - 造成死锁的可能
       - 当多个事务试图以不同顺序去锁定资源时，就可能会产生死锁;

       - 多个事务同时锁定同一个资源时，也会产生死锁;

	 例如：两个事务同时处理StockPrice表

	 - 事务1

	   #+BEGIN_EXAMPLE
	   START TRANSTARTION;
           UPDATE StockPrice SET close = 45 WHERE stock_id = 4 and date = '2015-10-25';
           UPDATE StockPrice SET close = 10 WHERE stock_id = 3 and date = '2015-10-26';
           COMMIT;

	   #+END_EXAMPLE

	 - 事务2

	   #+BEGIN_EXAMPLE
	   START TRANSTARTION;
           UPDATE StockPrice SET high = 23 WHERE  stock_id = 3 and date = '2015-10-26';
           UPDATE StockPrice SET high = 24 WHERE  stock_id = 4 and date = '2015-10-25';
           COMMIT;
	   #+END_EXAMPLE

       如果凑巧，两个事务都执行了第一条UPDATE语句，更新了一行数据，同时也锁定了改行，接着每个事务都尝试去执行第二条UPDATE语句，却发现改行已经被对方锁定，然后两个事务都会等待对方释放锁，同时又都持有对方所需要的锁，这样就会陷入死循环。除非有外部因素介入才可能解除死锁;

     - 解决方法

       1. 数据库实现了各种死锁检测和死锁超时机制. 检测到死锁循环依赖就返回一个错误;

       2. 当查询时间达到锁等待超时的设定后放弃锁请求，这种方式通常来说不太好;

       3. Innodb处理方法：将持有最少行级排他锁的事务进行回滚(这是相对比较简单的死锁回滚算法);

	  锁的行为和顺序是和存储引擎相关的。以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会;

     - 造成死锁的原因分类

       - 真正的数据冲突，这种情况很难避免。这种在程序设计的时候就要考虑的死锁的处理方法;

       - 存储引擎的实现方式导致的;

**** MVCC:多版本并发控制

     对于Mysql的Innodb存储引擎来讲，MVCC只能工作在 REPEATABLE READ 和 READ COMMITTED两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容,因为READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行，而不符合当前事务版本的数据行。而SERIALZABLE则会对所有读取的行加锁;

**** 表存储引擎转换

     - 直接修改该表的存储引擎
       #+BEGIN_EXAMPLE
       Alter table Mytable ENGINE='InnoDB';
       #+END_EXAMPLE
     - 导入导出的方法

       Mysqldump先将需要修改存储引擎的表给备份出来, 然后修改备份中的create table 语句修改表的名字为不同名字;

       因为同一个库中的表不能重复, 并且删除drop语句或者替换drop语句中的表的名字避免删除原来的表;

       注意：通常第一种方法比较慢, 它的实现原理是先将一张表的所有数据复制到另一个表中, 在复制期间可能会消耗系统所有的I/O能力, 同时会在原有表上加上读锁.所以在繁忙的时候需要特别小心.大多数情况最好选用第二中方法;

       如果转换表的存储引擎, 将会丢失和原引擎相关的所有特性.例如一张表从InnoDB-->Myisam-->InnoDB,原InnoDB上所有外键将都会丢失;

